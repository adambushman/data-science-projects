---
title: "Neural Network | Palmer Penguin Data"
description: "Leveraging neural network regression in R to predict species of penguin"
author: "Adam Bushman"
date: "11/25/2024"
format: 
    html:
        toc: true
        theme: simplex
        smooth-scroll: true
        embed-resources: true
execute:
    warning: false
    error: false
---


# Assignment Questions

## Name

>   What is your name? Include all team members if submitting as a group.

Adam Bushman [u6049169]; no group members.


## Perspective

>   From what perspective ar you conducting the analysis? (Who are you? / Who are you working for?)

I am a researcher working to classify some penguin specie observations as part of a research project on the heals of the Palmer Archipelago expedition from which the source data was collected.


## Question

>   What is your question? 

*Using the source data from the Palmer Archipelago, can our research group develop an accurate neural network model for classifying species of penguin?*

This is important to our research group in efforts to personalize protection efforts by species.


## Data set

>   Describe your dataset(s) including URL (if available)

Data sourced from Posit via their 
[{modeldata}](https://modeldata.tidymodels.org/index.html) package, accessed November 25th, 2024. The data was originally sourced from [{palmerpenguins}](https://allisonhorst.github.io/palmerpenguins/index.html) package. Described as "A data set from Gorman, Williams, and Fraser (2014) containing measurements from different types of penguins." Full citation below:

>   Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.



## Predictor(s) and target(s)

>   What is (are) your independent variable(s) and dependent variable(s)? Include variable type (binary, categorical, numeric).

The dependent variable (target) for this use-case to this situation is `species`, a categorical feature. The remaining variables are suitable as independent variables (predictors): 

*   Numeric: `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, `body_mass_g`
*   Categorical: `island` and `sex`

For a complete description of each feature, navigate to the [data dictionary](#data-dictionary).


## Model resonability

>   How are your variables suitable for your analysis method?

The variables chosen above are the extent of the dataset (all features used). The analysis method is for a neural network classification model. These variables and the analysis method are a natural pairing thanks to:

*   Multiclass classification
    *   There are likely to be some complex relationships to explain differences in `species`
*   Non-linear relationships
    *   


## Conclusions

>   What are your conclusions (include references to one or two CLEARLY INDICATED AND IMPORTANT graphs or tables in your output)?

#### Model effectiveness

...


## Assumptions

>   What are your assumptions and limitations? Did you include any robustness checks?

### Assumptions made throughout the analysis

...


### Robustness checks


# Assignment Workflow
 
## Analysis Prep

### Loading packages

```{r}
library('tidyverse')        # Wrapper for many convenient libraries
library('tidymodels')       # Wrapper for modeling libraries
library('modeldata')        # Contains data for the assignment
library('skimr')            # Quickly summarise data
library('gt')               # Render "great tables"

library('nnet')             # Loading neural network library
library('VIM')              # Nearest neighbors imputation
library('scutr')             # Library for generating a balanced data set w/ SMOTE
library('caret')            # Miscellaneous modeling functions
```

### Loading the data

We'll start off by referencing the "Palmer Penguin" data for the assignment from the `{modeldata}` package.

```{r}
peng_raw <- modeldata::penguins        # Data for the assignment
```

With it loaded into the session, let's get a sense for what we're working with.

### Data set inspection

Right away, I like to get acquainted with the data set. That means understanding what each column seeks to describe, confirming the granularity of the rows, and getting my arms around structure, completeness, distribution, etc.

Posit, the company behind `{modeldata}`, did not include a data dictionary; however, the source package, `{palmerpenguins}`, does feature a data dictionary. It is included below:

```{r}
#| include: false

peng_data_dict <- tibble(
    variable = c("species", "island", "bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g", "sex"), 
    datatype = c("<factor>", "<factor>", "<numeric>", "<numeric>", "<integer>", "<integer>", "<factor>"), 
    description = c(
        "Penguin species (Adelie, Chinstrap, Gentoo)", 
        "Island in Palmer Archipelago, Antartica (biscoe, Dream, or Torgerssen)", 
        "Bill length (millimeters)", 
        "Bill depth (millimeters)", 
        "Flipper length (millimeters)", 
        "Body mass (grams)", 
        "Penguin sex (female, male)"
    )
)
```

::: {#data-dictionary}
```{r}
#| html-table-processing: none

gt(peng_data_dict) %>%                                  # Create a "great tables" (gt) object
    cols_label(                                         # Rename some columns
        variable = "Variable Name", 
        datatype = "Data Type", 
        description = "Variable Description"
    ) %>%
    tab_options(
        column_labels.background.color = "#d9230f",     # Apply red header background
        column_labels.font.weight = "bold",             # Bold headers
        row.striping.background = '#FFFFFF'             # Remove row striping
    )
```
:::

Using the `{skimr}` package, we can get a comprehensive summary of the data.

```{r}
skim(peng_raw)
```
<br>

Initial observations include:

*   We have 344 rows and 7 columns; while a fairly small dataset, our neural network should be able to fit pretty fast
*   We have a couple missing values, namely `sex` (11 missing observations) and all of our numerics (2 missing observations); this means we'll have to do some imputation
*   We won't really have any skewed distributions
*   All our variables appear to be in the right data type
*   There's not a significant imbalance in classes
    *   `sex` is about even
    *   `species` and `island` have roughly 45-35-20 balancing each; one robustness check we can make later is to balance `species` in the training data


## Simple Exploratory Data Analysis



## Preprocessing

### Data cleaning

We've already mentioned the need to impute some values, specifically with `sex`, `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, and `body_mass_g`.

Given the narrow scope of this data and some finite categories like species and island, we should be able to impute using nearest neighbors instead of defaulting to the "mean" (in the case of the numerics) or "majority class" (in the case of `sex`). We'll use the `{VIM}` package and its `kNN()` function:

```{r}
peng_imputed <- kNN(
    peng_raw, 
    variable = c("sex", "bill_length_mm", "bill_depth_mm", "flipper_length_mm", "body_mass_g"), 
    k = 5
)
```

What we've said here is we're going to impute missing values for the 5 variables using the 5 nearest neighbors to each missing value. Let's double check `peng_imputed` has no missing values:

```{r}
sapply(peng_imputed, function(x) sum(is.na(x))) 
```

Perfect! Now, let's peak at the missing values for column:

```{r}
get_imputed <- function(x) {
    peng_imputed |> 
        filter({{ x }}) |>
        select(-c(sex_imp:body_mass_g_imp))
}
```

```{r}
print(get_imputed(sex_imp))
```

Looks like this predicted 4 `male` and 7 `female`. These missing values were all from two species and mostly two islands. A nearest neighbor approach in the data was a good idea since the rate of missing values wasn't consistent across all groups and distributions.

```{r}
print(get_imputed(bill_length_mm_imp))
```

We imputed two missing values for `bill_length_mm`. These observations were from completely diferent species and islands. The mean value we may have imputed is **43.9**, which likely would have lost some relationship value. The conditional mean by species at **38.8** and **47.5** do confirm our spread is about right. Unknown if that would have been a better value. We could test a model's sensitivity to this imputation later.

### Balancing

We don't have "significant" imbalance in our target class, but a 45-35-20 isn't ideal either. It's possible a neural network won't be sensitive to the imbalance. We'll test this as part of our robustness checks so we'll generate another set of data balanced with *Synthetic Minority Oversampling Technique* or SMOTE:

```{r}
idx = createDataPartition(peng_imputed$species, p = 0.7, list = FALSE)
peng_smote_test_imb <- peng_imputed[-idx,]
peng_smote_train_imb <- peng_imputed[idx,]
```

We're leaving 30% of the data imbalanced. This would be our pseudo "testing" set for the SMOTE data. Let's balance a pseudo "training" set.

Next, we preprocess the data via dummy encoding and then perform the smote balancing using the `{scutr}` package.

```{r}
peng_dmy <- dummyVars("~ . -species", peng_smote_train_imb)
peng_data_dmy <- data.frame(predict(peng_dmy, peng_smote_train_imb))

peng_smote_train_bal <- SCUT(
    peng_data_dmy |> mutate(species = peng_smote_train_imb$species), 
    "species", 
    undersample = undersample_kmeans, 
    usamp_opts = list(k = 7)
)

peng_smote_train_bal <- smote_results
```

```{r}
table(peng_smote_train_bal$species) |> prop.table()
```

Now, instead of a 45-35-20 split, we're at a nice 33-33-33 balance! 


## Model resources

### Splitting for training/testing sets

As is customary, we must split our data into training and testing sets. We'll put aside the testing set and work with training until we're comfortable with our model definition. The `{rsample}` package has a lot of helpful functions for this workflow. In just a couple lines we get training and testing sets.

```{r}

set.seed(819)                                                   # Set reproducible seed
split_obj <- initial_split(sac_clean, prop = 0.75)              # Split object

sac_train <- training(split_obj)                                # Split for training
sac_test <- testing(split_obj)                                  # Split for testing

```


## Training and tuning

### Fit a model

What we want to do is use `cv.glmnet` and specify the cross-validation therein.

```{r}

nFolds <- 10
foldid <- sample(rep(seq(nFolds), length.out = nrow(sac_train)))        # Randomize folds

model_fit <- cv.glmnet(                                                 # Run elastic net
    x = sac_train %>% select(-price_log) %>% data.matrix(),             # Predictors
    y = sac_train$price_log,                                            # Target
    family = "gaussian",                                                # Regression specification
    type.measure = "mse",                                               # Measure of interest
    nfolds = nFolds,                                                    # Number of cross-validation folds
    foldid = foldid                                                     # Reproducible folds
)

```

::: {.callout-note}
Output results shared below may differ slightly from the descriptions thereafter due to the nature of `cv.glmnet`.
:::


```{r}

model_fit

```

The fitted model description gives us some good info:

*   We see two values of $\lambda$, one corresponding to the minimum (`min`) mean squared error and the other one (`1se`) corresponding to within one standard error of the minimum
*   The index shows low far along the process each value was achieved
*   Measure is our means squared error (MSE)
*   SE is the standard error
*   Nonzero tells us how many features/predictors remained in the model given the chosen lambda

It's interesting to note that a near traditional OLS model gave the lowest MSE but a simpler model (thanks to a higher lambda) is nearly as good at a **~0.11** MSE.


### Evaluating tuning

Let's see if we can't plot these results:

```{r}

plot(model_fit)

```

`min` is indicated by the far left vertical line while `1se` is indicated by the far right vertical line.

We're also able to look at the coefficients:

```{r}

coef(model_fit, s = "lambda.1se")

```

At first blush, `sqft_log` and `zip` make a lot of sense given size and location are some of the most natural drivers of price. The absense of `type` and inclusion of `longitude` is curious.


## Final model

### Predict on testing

The next step is to train the previous model (`1se`) with the entire training data and then use it to predict training data values. Why `1se` and not `min`? We achieve a far simpler model with little impact to MSE.

Let's setup the prediction:

```{r}

sac_pred <- predict(                            # Make predictions
    model_fit,                                  # Original fit from above
    newx = sac_test %>%                         # Using the testing data we haven't worked with yet
        select(-price_log) %>% 
        data.matrix(),
    s = "lambda.1se"                            # Use the penalty within 1 standard error
)

head(sac_pred)

```

We now want to calculate the mean squared error. 

### Evaluating metrics

Ideally, we would be in the neighborhood of the values estimated from our cross-validation. Let's compile the predictions with the original values and do the necessary transformations.

```{r}

sac_test_r <-                                   
    sac_test %>%
    mutate(                                                     # Transform data back into natural scale
        .pred = sac_pred[,1],                                   # Predicted value (log)
        .pred_n = exp(.pred),                                   # Predicted value (natural)
        sqft = exp(sqft_log),                                   # Sqft (natural)
        price = exp(price_log),                                 # Sales price (natural)
        diff = .pred_n - price                                  # Difference in price (natural)
    )


mean((sac_test_r$.pred - sac_test_r$price_log)^2)               # Calculate mean squared error on log scale

```

We are, in fact, achieving about the same MSE with the testing data (**~0.12**) as we did with the training (**~0.11**).


## Results

### High value properties

The whole goal of this modeling exercise was to find high value properties, where our predicted price exceeds the sales price. 

Let's generate a table of the top 10 properties in modeled value:

::: {#property-list}
```{r}

sac_test_r %>%                                                          # Using the test data
    arrange(desc(diff)) %>%                                             # Sort by the difference
    select(city:type, sqft, price, .pred_n, diff) %>%                   # Select relevant columns
    head(10) %>%                                                        # Top-10 property values
    gt() %>%                                                            # Create a "great tables" object
    cols_label(                                                         # Add column labes
        city = "City", 
        zip = "Zip Code", 
        beds = "Bedroom No", 
        baths = "Bathroom No", 
        type = "Property Type", 
        sqft = "Square Feet", 
        price = "Sales Price", 
        .pred_n = "Predicted Price", 
        diff = "Modeled Value"
    ) %>%
    fmt_number(                                                         # Format sqft for decimals
        columns = c(sqft), 
        decimals = 0
    ) %>%
    fmt_currency(                                                       # Format pricing data for currency
        columns = c(price, .pred_n, diff), 
        decimals = 0, 
        suffixing = TRUE
    ) %>%
    tab_options(                                                        # Format the column headers
        column_labels.background.color = "#BE0000"
    )

```
:::

In the case of the very first property, our model suggests the property has a median worth of $208K but was sold at $57K. 1,512 square foot property with 4 bedrooms and 2 baths; at first blush, that does seem like great value.


### Plotting high value properties

A common next step would be to map the high value properties. We can do that with the `{leaflet}` package:

::: {#property-map}
```{r}

sac_map <-                                                              
    leaflet(height = 800, width = 800) %>%                              # Create a leaflet map object
    addTiles() %>%                                                      # Setup tile layer
    setView(lng = -121.478851, lat = 38.575764, zoom = 10)              # Localize zoom to Sacramento, CA

sac_map <- 
    sac_map %>%
    addProviderTiles("CartoDB.Positron") %>%                            # Use a grayscale map theme
    addCircleMarkers(                                                   # Add a circle point for every property
        data = sac_test_r %>% arrange(desc(diff)) %>% head(30),         # Top-30, high value properties
        lng = ~longitude,                                               # Mapped values
        lat = ~latitude,                                                # Mapped values
        radius = 6, 
        color = "#BE0000", 
        fillOpacity = 0.5
    )

sac_map

```
:::